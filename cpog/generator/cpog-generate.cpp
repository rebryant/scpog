// Translate DNNF representation into POG

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "report.h"
#include "clausal.hh"
#include "pog.hh"
#include "writer.hh"
#include "counters.h"

static bool multi_literal = true;
static bool use_lemmas = true;
static bool delete_files  =  true;
static bool forward_implication = true;
static bool reverse_implication = true;
static bool use_explicit_deletion = false;
static int drat_threshold = 0;
static int monolithic_threshold = 1000 * 1000;
static double tree_ratio_threshold = 5.0;
// Default limits vary by whether or not group literals 
static int bcp_limit_multiliteral = 1000;
static int bcp_limit_singleliteral = 1000;
static int bcp_limit = 0;
static int clause_limit = INT_MAX;
static bool weak_mode = false;

void usage(const char *name) {
    lprintf("Main parameters:\n");
    lprintf(" Usage: %s [-h] [-v VLEVEL] [-a p|f|r|b] [-k] FORMULA.cnf GRAPH.nnf [POG.cpog]\n", name);
    lprintf("  -h        Print this information\n");
    lprintf("  -v VLEVEL Set verbosity level\n");
    lprintf("  -a ACTION Action p:POG generation only, f:forward implication only, r:reverse implication only, b:both implications\n");
    //    lprintf("  -w        Weak projection.  Final output will be in DNNF, not d-DNNF\n");
    //    lprintf("  -d        Use explicit input clause deletion\n");
    lprintf("  -k        Keep intermediate solver files\n");
    //    lprintf("  -p UPLY   Generate CNF of negated projected formula\n");
    lprintf("FORMULA.cnf CNF representation of formula\n");
    lprintf("GRAPH.nnf Representation generated by D4\n");
    lprintf("POG.cpog    Output file\n");
    lprintf("\n");
    lprintf("Less used parameters:\n");
    lprintf("           [-L LOG] [-m MONO] [-r RAT] [-C CLIM] [-b BLIM] [-t THRESH] [-s] [-e]\n");
    //    lprintf("  -d        Explicitly delete input clauses\n");
    lprintf("  -L LOG    Record all results to file LOG\n");
    lprintf("  -m MONO   Monolithically validate subgraphs with tree size <= MONO (use -1 for unbounded)\n");
    lprintf("  -r RAT    Upper limit on tree ratio for using any monolithic validation\n");
    lprintf("  -C CLIM   Limit total number of clauses in input + proof (default = %d)\n", clause_limit);
    lprintf("  -b BLIM   Limit depth of Boolean constraint propagation for contradiction proofs\n");
    lprintf("  -t THRESH Use drat-trim on proofs when SAT problems are above THRESH clauses (default = %d)\n", drat_threshold);
    lprintf("  -s        Prove each literal separately, rather than combining into single proof\n");
    lprintf("  -e        Expand each node, rather than using lemmas\n");
    exit(0);
}

const char *prefix = "c GEN:";

static void stat_report() {
    if (verblevel < 1)
	return;
    bool proof_generated = forward_implication || reverse_implication;
    double elapsed = get_elapsed();
    lprintf("%s Formula\n", prefix);
    lprintf("%s    input variables: %d\n", prefix, get_count(COUNT_VAR));
    if (get_count(COUNT_DATA_VAR)) 
	lprintf("%s        data vars  : %d\n", prefix, get_count(COUNT_DATA_VAR));
    lprintf("%s    input clauses  : %d\n", prefix, get_count(COUNT_CLAUSE));
    int nprod = get_count(COUNT_POG_AND);
    int nsum = get_count(COUNT_POG_OR);
    int ndsum =  get_count(COUNT_POG_DECISION_OR);
    int nskolem = get_count(COUNT_POG_SKOLEM);
    int skolem_degree_min = get_histo_min(HISTO_SKOLEM_DEGREE);
    int skolem_degree_max = get_histo_max(HISTO_SKOLEM_DEGREE);
    double skolem_degree_avg = get_histo_avg(HISTO_SKOLEM_DEGREE);
    int product_degree_min = get_histo_min(HISTO_PRODUCT_DEGREE);
    int product_degree_max = get_histo_max(HISTO_PRODUCT_DEGREE);
    double product_degree_avg = get_histo_avg(HISTO_PRODUCT_DEGREE);
    lprintf("%s POG nodes\n", prefix);    
    lprintf("%s    product   : %d\n", prefix, nprod);
    if (nprod > 0)
	lprintf("%s        product degree: min %d avg %.2f max %d\n", prefix, product_degree_min, product_degree_avg, product_degree_max);
    lprintf("%s    sum       : %d\n", prefix, nsum);
    if (forward_implication)
	lprintf("%s        mutex : %d\n", prefix, nsum-ndsum);
    lprintf("%s    Skolem    : %d\n", prefix, nskolem);
    if (nskolem > 0)
	lprintf("%s        Skolem degree : min %d avg %.2f max %d\n", prefix, skolem_degree_min, skolem_degree_avg, skolem_degree_max);
    lprintf("%s    node TOTAL: %d\n", prefix, nsum+nprod+nskolem);
    if (proof_generated) {
	lprintf("%s Other nodes\n", prefix);    
	lprintf("%s    aux product: %d\n", prefix, get_count(COUNT_AUX_AND));
	lprintf("%s Node visits\n", prefix);
	int vprod = get_count(COUNT_VISIT_AND);
	int vps = get_count(COUNT_VISIT_AND_SAT);
	int vpb = vprod-vps;
	int vsum = get_count(COUNT_VISIT_OR);
	int vskolem = get_count(COUNT_VISIT_SKOLEM);
	lprintf("%s    product/BCP: %d\n", prefix, vpb);
	lprintf("%s    product/SAT: %d\n", prefix, vps);
	lprintf("%s    sum        : %d\n", prefix, vsum);
	lprintf("%s    Skolem     : %d\n", prefix, vskolem);
	lprintf("%s    visit TOTAL: %d\n", prefix, vsum+vprod+vskolem);
	lprintf("%s Lemmas\n", prefix);
	lprintf("%s    definitions : %d\n", prefix, get_count(COUNT_LEMMA_DEFINITION));
	lprintf("%s    applications: %d\n", prefix, get_count(COUNT_LEMMA_APPLICATION));
	lprintf("%s    duplicates  : %d\n", prefix, get_count(COUNT_LEMMA_DUPLICATES));
	lprintf("%s    merged args : %d\n", prefix, get_count(COUNT_LEMMA_ARGUMENT_MERGE));
    }
    int problem_count = get_histo_count(HISTO_PROBLEM);
    int problem_min = get_histo_min(HISTO_PROBLEM);
    int problem_max = get_histo_max(HISTO_PROBLEM);
    double problem_avg = get_histo_avg(HISTO_PROBLEM);
    if (problem_count > 0) {
	lprintf("%s SAT Problem Clause Counts (%d instances)\n", prefix, problem_count);
	lprintf("%s    PROBLEM MIN   : %d\n", prefix, problem_min);
	lprintf("%s    PROBLEM AVG   : %.2f\n", prefix, problem_avg);
	lprintf("%s    PROBLEM MAX   : %d\n", prefix, problem_max);
    }

    if (problem_count > 0) {
	int proof_count = get_histo_count(HISTO_PROOF);
	int proof_min = get_histo_min(HISTO_PROOF);
	int proof_max = get_histo_max(HISTO_PROOF);
	double proof_avg = get_histo_avg(HISTO_PROOF);

	lprintf("%s SAT Proof Clause Counts\n", prefix);
	if (proof_count > 0) {
	    lprintf("%s    PROOF MIN   : %d\n", prefix, proof_min);
	    lprintf("%s    PROOF AVG   : %.2f\n", prefix, proof_avg);
	    lprintf("%s    PROOF MAX   : %d\n", prefix, proof_max);
	}
    }

    int cd  = get_count(COUNT_DEFINING_CLAUSE);
    int cda = get_count(COUNT_DEFINING_AUX_CLAUSE);
    long cv = get_long_count(COUNT_VIRTUAL_CLAUSE);
    int cdp = cd-cda;
    int caj = get_count(COUNT_AND_JUSTIFICATION_CLAUSE);
    int coj = get_count(COUNT_OR_JUSTIFICATION_CLAUSE);
    int csj = get_count(COUNT_SKOLEM_JUSTIFICATION_CLAUSE);
    int clj = get_count(COUNT_LITERAL_JUSTIFICATION_CLAUSE);
    int cla = get_count(COUNT_LEMMA_APPLICATION_CLAUSE);
    int clm = get_count(COUNT_MONOLITHIC_CLAUSE);
    int clx = get_count(COUNT_MUTEX_CLAUSE);
    int clu = get_count(COUNT_UNSAT_CLAUSE);
    lprintf("%s Clauses\n", prefix);    
    if (cv > 0)
	lprintf("%s    POG definition       : %d regular + %ld virtual = %ld total\n", prefix, cdp, cv, cdp+cv);
    else
	lprintf("%s    POG definition       : %d\n", prefix, cdp);
    if (proof_generated) {
	lprintf("%s    AUX definition       : %d\n", prefix, cda);
	lprintf("%s    product justification: %d\n", prefix, caj);
	lprintf("%s    sum justification    : %d\n", prefix, coj);
	lprintf("%s    Skolem justification : %d\n", prefix, csj);
	lprintf("%s    literal justification: %d\n", prefix, clj);
	lprintf("%s    lemma application    : %d\n", prefix, cla);
	lprintf("%s    monolithic proof     : %d\n", prefix, clm);
	lprintf("%s    unsat proof          : %d\n", prefix, clu);
    }
    int hm = get_count(COUNT_MUTEX_HINT);
    int ha = get_count(COUNT_ADDITION_HINT);
    int hd = get_count(COUNT_DELETION_HINT);
    if (forward_implication)
	lprintf("%s    mutex proof          : %d\n", prefix, clx);
    lprintf("%s    clause TOTAL         : %d\n", prefix, cdp+cda+coj+csj+caj+clj+cla+clm+clx+clu);
    lprintf("%s Hints\n", prefix);
    lprintf("%s    Mutex      : %d\n", prefix, hm);
    lprintf("%s    Addition   : %d\n", prefix, ha);
    lprintf("%s    Deletion   : %d\n", prefix, hd);
    lprintf("%s    Hint TOTAL : %d\n", prefix, hm+ha+hd);
    double setup_time = get_timer(TIME_SETUP);
    double sat_time_total = get_timer(TIME_SAT_TOTAL);
    double sat_time_setup = get_timer(TIME_SAT_SETUP);
    double sat_time_forward = sat_time_total - sat_time_setup;
    double delete_time = get_timer(TIME_DELETE);
    double optimize_time = get_timer(TIME_OPTIMIZE);
    lprintf("%s Time\n", prefix);
    lprintf("%s    Setup POG           : %.2f\n", prefix, setup_time);
    lprintf("%s             SAT execution  : %.2f\n", prefix, sat_time_setup);
    lprintf("%s             Other setup    : %.2f\n", prefix, setup_time - sat_time_setup);
    if (proof_generated) {
	lprintf("%s    Forward implication : %.2f\n", prefix, elapsed-(setup_time+delete_time));
	lprintf("%s             SAT execution  : %.2f\n", prefix, sat_time_forward);
	lprintf("%s             Other forward  : %.2f\n", prefix, elapsed-(setup_time+delete_time+sat_time_forward)); 
	lprintf("%s    Reverse implication : %.2f\n", prefix, delete_time);
    }
    if (optimize_time > 0)
	lprintf("%s   Optimize CNF        : %.2f\n", prefix, optimize_time);
    lprintf("%s    Time TOTAL          : %.2f\n", prefix, elapsed);
}

void panic() {
    err(false, "Execution incomplete.  Here's the results so far:\n");
    stat_report();
    err(false, "Results not valid\n");
}


// Return value is return code for program
static int run(FILE *cnf_file, FILE *nnf_file, Pog_writer *pwriter, FILE *pcnf_file) {
    start_timer();
    Cnf_reasoner cnf(cnf_file);
    double elapsed = get_elapsed();
    lprintf("%s Time %.2f  Read input file with %d variables and %d clauses\n", prefix, elapsed, cnf.max_variable(), (int) cnf.clause_count());
    fclose(cnf_file);
    if (cnf.failed()) {
	fprintf(stderr, "Aborted\n");
	return 1;
    }
    cnf.use_explicit_deletion = use_explicit_deletion;
    cnf.weak_sum = weak_mode;
    cnf.multi_literal = multi_literal;
    cnf.use_lemmas = use_lemmas;
    cnf.delete_files = delete_files;
    cnf.drat_threshold = drat_threshold;
    cnf.clause_limit = clause_limit;
    cnf.bcp_limit = cnf.bcp_limit;
    cnf.monolithic_threshold = monolithic_threshold;
    cnf.tree_ratio_threshold = tree_ratio_threshold;
    Pog pog(&cnf, !forward_implication || weak_mode);
    if (verblevel >= 2)
	pwriter->enable_comments();
    cnf.enable_pog(pwriter);
    if (!pog.read_d4ddnnf(nnf_file)) {
	err(false, "Error reading D4 NNF file.  Aborting proof generation\n");
	return 1;
    }
    elapsed = get_elapsed();
    lprintf("%s Time %.2f  Generated POG representation\n", prefix, elapsed);
    incr_timer(TIME_SAT_SETUP, get_timer(TIME_SAT_TOTAL));
    elapsed = get_elapsed();
    incr_timer(TIME_SETUP, elapsed);
    int root_literal = pog.get_root();
    bool ok = true;
    bool unsat = root_literal == 0;
    if (forward_implication || reverse_implication) {
	report(3, "Justifying root literal %d\n", root_literal);
	int unit_cid = 0;
	if (forward_implication) {
	    if (unsat) {
		pog.justify_unsatisfiable();
	    } else if (pog.is_node_type(root_literal, POG_TRUE)) {
		report(3, "Tautology\n");
		unit_cid = pog.get_node(IABS(root_literal))->get_defining_cid();
	    } else {
		unit_cid = pog.justify(root_literal, false, use_lemmas);
		if (unit_cid == 0) {
		    err(false, "Failed to justify root literal %d\n", root_literal);
		    // Undercount
		    return 10;
		}
	    }
	    lprintf("%s Time %.2f  Completed forward implication proof\n", prefix, get_elapsed());
	} else
	    unit_cid = cnf.assert_literal(root_literal);
	if (!unsat) {
	    cnf.delete_assertions();
#if DELETE_FULL
	    elapsed = get_elapsed();
	    lprintf("%s Time %.2f  Deleted asserted clauses\n", prefix, elapsed);
#endif
	    if (reverse_implication && use_explicit_deletion) {
		double start_deletion = get_elapsed();
		ok = pog.delete_input_clauses(unit_cid);
		elapsed = get_elapsed();
		lprintf("%s Time %.2f  Deleted input clauses\n", prefix, elapsed);
		incr_timer(TIME_DELETE, elapsed-start_deletion);
	    }
	}
    }
    pwriter->finish_file();
    if (pcnf_file != NULL) {
	double start = get_elapsed();
	Cnf_opt *opt_cnf = new Cnf_opt(pog.data_variables);
	std::unordered_set<int> sofar;
	pog.export_subgraph(root_literal, opt_cnf, sofar, true);
	// Negated unit clause for root
	Clause *rcp = new Clause(-root_literal);
	opt_cnf->add_clause(rcp);
	delete rcp;
#if 0
	pog.clear();
#endif
	opt_cnf->optimize();
	opt_cnf->show(pcnf_file);
	fclose(pcnf_file);
	elapsed = get_elapsed();
	lprintf("%s Time %.2f  Generated CNF for negated result\n", prefix, elapsed);
	double elapsed = get_elapsed() - start;
	incr_timer(TIME_OPTIMIZE, elapsed);
	delete opt_cnf;
    } else {
#if 0
	pog.clear();
#endif
    }
    return ok ? 0 : 20;
}

int main(int argc, char *const argv[]) {
    FILE *cnf_file = NULL;
    FILE *nnf_file = NULL;
    Pog_writer *pwriter = NULL;
    FILE *pcnf_file = NULL;
    verblevel = 1;
    int c;
    int action;
    float r;
    set_panic(panic);
    while ((c = getopt(argc, argv, "ha:r:m:v:L:C:b:t:p:dsekw")) != -1) {
	switch (c) {
	case 'h':
	    usage(argv[0]);
	    break;
	case 'a':
	    if (strlen(optarg) != 1) {
		lprintf("Invalid action '%s'\n", optarg);
		usage(argv[0]);
	    }
	    action = optarg[0];
	    switch (action) {
	    case 'p':
		forward_implication = reverse_implication = false;
		break;
	    case 'f':
		reverse_implication = false;
		break;
	    case 'r':
		forward_implication = false;
		break;
	    case 'b':
		break;
	    default:
		lprintf("Invalid action '%s'\n", optarg);
		usage(argv[0]);
	    }
	    break;
	case 'm':
	    monolithic_threshold = atoi(optarg);
	    break;
	case 'r':
	    tree_ratio_threshold = atof(optarg);
	    break;
	case 'v':
	    verblevel = atoi(optarg);
	    break;
	case 'L':
	    set_logname(optarg);
	    break;
	case 'C':
	    clause_limit = atoi(optarg);
	    break;
	case 'b':
	    bcp_limit_multiliteral = bcp_limit_singleliteral = atoi(optarg);
	    break;
	case 't':
	    drat_threshold = atoi(optarg);
	    break;
	case 'p':
	    pcnf_file = fopen(optarg, "w");
	    if (pcnf_file == NULL) {
		lprintf("Can't open output CNF file %s\n", optarg);
		exit(1);
	    }
	case 's':
	    multi_literal = false;
	    break;
	case 'd':
	    use_explicit_deletion = true;
	    break;
	case 'e':
	    use_lemmas = false;
	    break;
	case 'k':
	    delete_files = false;
	    break;
	case 'w':
	    weak_mode = true;
	    break;
	case '?':
	default:
	    lprintf("Unknown option '%c'\n", c);
	    usage(argv[0]);
	}
    }
    int argi = optind;
    if (argi >= argc) {
	lprintf("Name of input CNF file required\n");
	usage(argv[0]);
    }
    cnf_file = fopen(argv[argi], "r");
    if (cnf_file == NULL) {
	lprintf("Can't open '%s'\n", argv[argi]);
	exit(1);
    }
    init_namer(argv[argi]);
    argi++;
    if (argi >= argc) {
	lprintf("Name of input NNF file required\n");
	usage(argv[0]);
    }
    nnf_file = fopen(argv[argi], "r");
    if (nnf_file == NULL) {
	fprintf(stderr, "Can't open '%s'\n", argv[argi]);
	exit(1);
    }
    argi++;
    if (argi < argc) {
	pwriter = new Pog_writer(argv[argi]);
	if (pwriter == NULL) {
	    fprintf(stderr, "Can't open '%s'\n", argv[argi]);
	    exit(1);
	}
	argi++;
    } else
	pwriter = new Pog_writer();

    // Choose BCP limit
    bcp_limit =  multi_literal ? bcp_limit_multiliteral : bcp_limit_singleliteral;

    if (forward_implication || reverse_implication) {
	const char *sname;
	switch (SOLVER) {
	case KISSAT:
	    sname = "kissat";
	    break;
	case CADICAL:
	    sname = "cadical-drat";
	    break;
	case LCADICAL:
	    sname = "cadical-lrat";
	    break;
	case TCADICAL:
	    sname = "cadical-trimmed-lrat";
	    break;
	}

	lprintf("%s Program options\n", prefix);
	lprintf("%s   Multi-literal:       %s\n", prefix, multi_literal ? "yes" : "no");
	lprintf("%s   Use lemmas:          %s\n", prefix, use_lemmas ? "yes" : "no");
	lprintf("%s   Delete files:        %s\n", prefix, delete_files ? "yes" : "no");
	lprintf("%s   Forward implication: %s\n", prefix, forward_implication ? "yes" : "no");
	lprintf("%s   Reverse implication: %s\n", prefix, reverse_implication ? "yes" : "no");
	lprintf("%s   Explicit deletion:   %s\n", prefix, use_explicit_deletion ? "yes" : "no");
	lprintf("%s   DRAT threshold:      %d\n", prefix, drat_threshold);
	lprintf("%s   Clause limit:        %d\n", prefix, clause_limit);
	lprintf("%s   BCP limit:           %d\n", prefix, bcp_limit);
	lprintf("%s   Weak mode            %s\n", prefix, weak_mode ? "yes" : "no");
	if (monolithic_threshold >= 0)
	    lprintf("%s   Monolithic threshold %d\n", prefix, monolithic_threshold);
	else
	    lprintf("%s   Monolithic threshold unbounded\n", prefix);
	lprintf("%s   Tree ratio threshold %.2f\n", prefix, tree_ratio_threshold);
	lprintf("%s   Solver:              %s\n", prefix, sname);
    }
    int return_code = 0;
    try {
	return_code = run(cnf_file, nnf_file, pwriter, pcnf_file);
    } catch (const std::bad_alloc &e) {
	err(true, "Memory allocation error\n");
    }
    stat_report();
    
    return return_code;
}
